# SBox Circuit

## Программа для построения логической схемы для заданного S-блока на языке verilog одним из шести методов. Рассчитана для работы с S-блоками не больше, чем 16 x 16.

Использование: ./<prog> --method meth [--infile file] [--outfile file]

Реализованные методы (ключ --method):
 * "simple": наивный метод;
 * "upgSimple": улучшенный наивный метод;
 * "Shannon": метод Шеннона;
 * "Lupanov": метод Лупанова;
 * "minDNF": метод на основе упрощения ДНФ, использует алгоритм ESPRESSO (см ниже);
 * "newMethod": метод, предложенным автором.

Программа принимает на вход текстовый файл, задающий перестановку pi. Если не указан файл по ключу --infile, то прозводится попытка открыть файл input.txt в папке с программой.
Входной текстовый файл должен иметь следующий формат:

n
pi(0) pi(1) ... pi(2^n - 1)

Полученная схема выводится в файл, указанный по ключу --outfile. Если выходной файл не указан, схема выводится в stdout.

Для получения схемы методом на основе упрощения ДНФ требуется сторонняя программа ESPRESSO, в которой реализован одноименный метод упрощения ДНФ.
Найти ее можно, например, по этому адресу: https://github.com/classabbyamp/espresso-logic.

Чтобы получить схему этим методом, надо:
1. Запустить программу espressoPrint, передав в качестве входного параметра файл с S-блоком и сохранить вывод в файл (например, espressoInput.txt)
2. Запустить программу ESPRESSO: ./<espresso-prog> -Dso espressoInput.txt > espressoOutput.txt. (Также можно добавить ключ -S1, чтобы посчитать точный минимум, работает для n >= 10).
3. Передать файл espressoOutput на вход исходной программы (./<prog> --method minDNF --infile espressoOutput).

При n = 15, 16 данный метод работает слишком медленно.

При реализации схемы по авторскому алгоритму программа строит бинарное дерево по следующему правилу, выполняемому для каждого узла, начиная с корня:
 * находится пара векторов с наибольшим количеством общих единиц
 * вектор, состоящий только из общих единиц (и остальных нулей) кладется в правого потомка
 * два вектора разницы кладутся в левого потомка
 * если нет векторов с общими единицами или остался всего один вектор, процесс прекращается.
 
Далее, если выбран новый метода, программа считает сложность схемы из функциональных элементов в базисе конъюнкция, дизъюнкция, отрицание (не учитывается при учете сложности), которая реализует S-блок, заданный на входе. При вычислении сложности не учитывается сложность дешифратора размерности n.

Также в комлект входит:
 * утилита generateSbox для генерации случайного S-блока размером n x n (использование: ./<gen-prog> n);
 * утилита для печати входов и выходов для проверки схемы на языке verilog (использование: ./<print-prog> infile); печатает входы в файл inputs.txt, выходы в файл outputs.txt
 * test suite; набор файлов на языке verilog:
   * header.v - указана размерность S-блока
   * inputs.txt - входы для теста
   * outputs.txt - правильные результаты теста (значения перестановки)
   * sbox_tester.v - главный файл с тестом
   * sbox.v - файл со схемой S-блока; схему, полученную с помощью основной программы, надо записать в этот файл
   * файлы с реализацией более простых конструкций:
     * decoders.v - дешифраторы
     * all_functions.v - дизъюнкции всех возможных элементов, необходимы для метода Лупанова
     * phi.v - реализация всех возможных функций от 2 и 3 переменных, необходимы для метода Шеннона
